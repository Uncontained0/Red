import{_ as e,c as t,o as a,a as l}from"./app.1de793c8.js";const w=JSON.parse('{"title":"Promise","description":"","frontmatter":{},"headers":[{"level":2,"title":"Promise Object","slug":"promise-object","link":"#promise-object","children":[{"level":3,"title":"new","slug":"new","link":"#new","children":[]},{"level":3,"title":"Resolve","slug":"resolve","link":"#resolve","children":[]},{"level":3,"title":"Reject","slug":"reject","link":"#reject","children":[]},{"level":3,"title":"Then","slug":"then","link":"#then","children":[]},{"level":3,"title":"Catch","slug":"catch","link":"#catch","children":[]},{"level":3,"title":"Finally","slug":"finally","link":"#finally","children":[]},{"level":3,"title":"Await","slug":"await","link":"#await","children":[]}]}],"relativePath":"0.1.x/util/promise.md"}'),i={name:"0.1.x/util/promise.md"},o=l('<h1 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-hidden="true">#</a></h1><p>Promises are objects that represent a value that may not be available yet. They are most commonly used to represent asynchronous operations.</p><p>There are plenty of resources that explain promises in detail, far better than I ever could.</p><div class="info custom-block"><p class="custom-block-title">Why does Red use a custom promise implementation?</p><ol><li><p>I&#39;m a dirty pascal case lover. I&#39;m not ashamed to admit it.</p></li><li><p>I find roblox-lua-promise to be somewhat bloated. It&#39;s a great implementation, I just find things like <code>await</code>, <code>awaitStatus</code>, and <code>expect</code> to be too much.</p></li></ol></div><h2 id="promise-object" tabindex="-1">Promise Object <a class="header-anchor" href="#promise-object" aria-hidden="true">#</a></h2><h3 id="new" tabindex="-1">new <a class="header-anchor" href="#new" aria-hidden="true">#</a></h3><p><code>(Callback: (Resolve: (...any) -&gt; (), Reject: (...any) -&gt; ()) -&gt; ()) -&gt; Promise</code></p><p>Creates a new promise. The callback will be called in a new thread. The callback will be passed two functions, <code>Resolve</code> and <code>Reject</code>. The callback should call <code>Resolve</code> with the value that the promise should resolve to, or <code>Reject</code> with the error that the promise should reject with.</p><h3 id="resolve" tabindex="-1">Resolve <a class="header-anchor" href="#resolve" aria-hidden="true">#</a></h3><p><code>(...any) -&gt; Promise</code></p><p>Returns a new promise that instantly resolves with the value that was passed to this function.</p><h3 id="reject" tabindex="-1">Reject <a class="header-anchor" href="#reject" aria-hidden="true">#</a></h3><p><code>(...any) -&gt; Promise</code></p><p>Returns a new promise that instantly rejects with the error that was passed to this function.</p><h3 id="then" tabindex="-1">Then <a class="header-anchor" href="#then" aria-hidden="true">#</a></h3><p><code>(self, ResolveCallback: (...any) -&gt; ()?, RejectCallback: (...any) -&gt; ()?) -&gt; Promise</code></p><p>Returns a new promise that will be resolved with the value returned by the <code>ResolveCallback</code>, or resolved with the value returned by the <code>RejectCallback</code>. If a promise is resolved or rejected without the corrosponding callback being set, the new promise will propagate the same state.</p><h3 id="catch" tabindex="-1">Catch <a class="header-anchor" href="#catch" aria-hidden="true">#</a></h3><p><code>(self, RejectCallback: (...any) -&gt; ()?) -&gt; Promise</code></p><p>Returns a new promise that will be resolved with the value returned by the <code>RejectCallback</code>.</p><h3 id="finally" tabindex="-1">Finally <a class="header-anchor" href="#finally" aria-hidden="true">#</a></h3><p><code>(self, Callback: () -&gt; ()) -&gt; Promise</code></p><p>Returns a new promise that will be resolved with the same value as the original promise. The <code>Callback</code> will be called when the original promise is resolved or rejected.</p><h3 id="await" tabindex="-1">Await <a class="header-anchor" href="#await" aria-hidden="true">#</a></h3><p><code>(self) -&gt; (...any)</code></p><p>Yields the thread until the promise is resolved or rejected. If the promise is resolved, the value that the promise was resolved with will be returned. If the promise is rejected, the error that the promise was rejected with will be thrown.</p>',26),r=[o];function s(c,h,d,n,p,m){return a(),t("div",null,r)}const b=e(i,[["render",s]]);export{w as __pageData,b as default};
