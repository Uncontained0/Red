import{_ as e,c as t,o as n,a}from"./app.1de793c8.js";const u=JSON.parse('{"title":"Signal","description":"","frontmatter":{},"headers":[{"level":2,"title":"Connection Object","slug":"connection-object","link":"#connection-object","children":[{"level":3,"title":"Disconnect","slug":"disconnect","link":"#disconnect","children":[]}]},{"level":2,"title":"Signal Object","slug":"signal-object","link":"#signal-object","children":[{"level":3,"title":"new","slug":"new","link":"#new","children":[]},{"level":3,"title":"Connect","slug":"connect","link":"#connect","children":[]},{"level":3,"title":"Fire","slug":"fire","link":"#fire","children":[]},{"level":3,"title":"Wait","slug":"wait","link":"#wait","children":[]}]}],"relativePath":"0.1.x/util/signal.md"}'),i={name:"0.1.x/util/signal.md"},c=a('<h1 id="signal" tabindex="-1">Signal <a class="header-anchor" href="#signal" aria-hidden="true">#</a></h1><p>You don&#39;t need me to explain signals to you. Signals are collections of functions that are called when the signal is fired.</p><p>Signals are not actually used anywhere within Red, but it&#39;s convenient to have a signal implementation that uses Red&#39;s promises.</p><h2 id="connection-object" tabindex="-1">Connection Object <a class="header-anchor" href="#connection-object" aria-hidden="true">#</a></h2><p>Connections are objects that represent a connection to a signal. They have a <code>disconnect</code> method that can be used to disconnect the connection. Connections will be garbage collected after they are disconnected.</p><h3 id="disconnect" tabindex="-1">Disconnect <a class="header-anchor" href="#disconnect" aria-hidden="true">#</a></h3><p><code>(self) -&gt; ()</code></p><p>Disconnects the connection.</p><h2 id="signal-object" tabindex="-1">Signal Object <a class="header-anchor" href="#signal-object" aria-hidden="true">#</a></h2><p>Signals are objects that can be connected to and fired. They have a <code>connect</code> method that can be used to connect a function to the signal. They have a <code>fire</code> method that can be used to fire the signal.</p><h3 id="new" tabindex="-1">new <a class="header-anchor" href="#new" aria-hidden="true">#</a></h3><p><code>() -&gt; Signal</code></p><p>Creates a new signal.</p><h3 id="connect" tabindex="-1">Connect <a class="header-anchor" href="#connect" aria-hidden="true">#</a></h3><p><code>(self, Callback: (...any) -&gt; ()) -&gt; Connection</code></p><p>Connects a callback to the signal. The callback will be called when the signal is fired. The callback will be called with the arguments that were passed to the <code>Fire</code> method.</p><h3 id="fire" tabindex="-1">Fire <a class="header-anchor" href="#fire" aria-hidden="true">#</a></h3><p><code>(self, ...any) -&gt; ()</code></p><p>Fires the signal. All callbacks connected to the signal will be called with the arguments that were passed to this method.</p><h3 id="wait" tabindex="-1">Wait <a class="header-anchor" href="#wait" aria-hidden="true">#</a></h3><p><code>(self) -&gt; Promise</code></p><p>Returns a promise that will be resolved when the signal is next fired. The promise will be resolved with the arguments that were passed to the <code>Fire</code> method.</p>',22),o=[c];function l(s,d,h,r,g,p){return n(),t("div",null,o)}const f=e(i,[["render",l]]);export{u as __pageData,f as default};
